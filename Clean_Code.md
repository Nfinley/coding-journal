# Clean Code

Notes from book club and reading (started 11/1/2019)

## Ch 1: Clean Code

- Total Cost of Owning a Mess
  - LeBlanc's law: Later equals never
  - The larger your code bass gets and the messier it gets, the less productivity you see
- Attitude
  - It is our job to defend the code with equal passion to our managers defending the schedule and requirements
- The Primal Conundrum
  - Developers know that previous messes slow them down, yet they feel the pressure to make messes in order to meet deadlines
  - However, the second part is wrong, you will not make the deadline by making a mess
  - The only way to make the deadline - the only way to go fast - is to keep the code as cleas as possible at all times
- The Art of Clean Code?
  - Requires use of "code-sense"
  - A programmer who can write clean code is an artist who can take a blank screen through a series of transformations until it is an elegantly coded system
- What is Clean Code?
  - Bjarne Stroustrup (Inventor of C++)
    - Likes code to be elegant and efficient, and clean code does one thing well
    - Clean code exhibits close attention to detail
    - Clean code is focused
  - Grady Booch (author of OO analysis and design with applications)
    - He says: Clean code is simple and direct
    - He takes a readability perspective and we should have 'crisp abstractions'
      - In that our code should be matter of fact as opposed to speculative
  - "Big" Dave Thomas (founder of OTI, gofather Eclipse strategy)
    - He focuses on readability but also asserts clean code makes it easy for other people to enhance it
    - He also ties cleaniness to tests
  - Michael Feathers (author of Working Effectively with Legacy Code)
    - Clean code looks like it was written by someone who cares about the code they write
    - Clean code is code that has been taken care of
  - Ron Jeffries (author of extreme programming Installed and adventures in C#)
    - Run all tests
    - Contains no duplication
    - Expresses all the esign ideas that are in the system
    - He focuses on Duplication and expressiveness
    - Also functions should do one thing, tiny abstractions
  - Ward Cunningham (inventor of Wiki, godfather of all those who care about code)
    - He expects that when you read clean code you won't be suprised at all, you won't expend much effort
    - Makes the language look like it was made for the problem
- We are Authors
  - Because we spend about 10:1 ratio of reading to writing code making it easier to read makes it easier to write
- The Boy Scout Rule

  - Code must be kept clean over time
  - Leave the campground cleaner than you found it

## Ch 2: Meaningful Names

- Use Intention-Revealing Names
  - If a name requires a comment then it does not reveal intent
  - Name with intention
- Avoid Disinformation
  - We must avoid levaing false queus that obscure the meaning of the code
  - Spelling similiar concepts similarily is information, using inconsistent spellins is disinformation
- Make Meaningful Distinctions
  - Number-series name is the opposite of intentional naming
  - Don't use language reserved words in naming like `variable` or `table`
- Use Pronounceable Names
  - ie: use `generationTimeStamp` instead of `genymdhms`
- Use Searchable Names
  - Single letter names are not advised
- Avoid Encodings
  - They are seldom pronounceable and are easy to mis-type
- Hungarian Notation
- Member Prefixes
  - you don't need to prefix member vairables
- Interfaces and Implementations
  - Don't code for the interface (ie: `IShapeFactory`)
- Avoid Mental Mapping
  - Clarity is King
- Class Names
  - They should have noun or noun phrare names like `Customer` or `AddressParser`
  - Should not be a verb
- Method Names
  - Should have verb or verb phrase names like `postPayment`, `deletePage`
- Don't be Cute
  - Say what you mean, mean what you say
- Pick One Word per Concept
  - Ie pick one from `fetch, get and retrieve` when naming things of this type
- Don't Pun
- Use Solution Domain Names
  - Its not wise to draw all names from the problem domain because we don't want to ask the customer they mean
  - Use computer science terms where applicable
- Use Problem Domain Names
  - When no "programmer-eese" is available use the problem domain name
- Add Meaningful Context
  - see listing 2-2 pg. 28 and 29
- Don't Add Gratuitous Context
  - If you app is Gas Station Deluxe don't add `GSD` to every class or function
  - Shorter Names are generally better than longer name so long as they are clear

## Ch 3: Functions

- Small!
  - They should be small and the second rule is that they should be smaller than that
  - No more than 20 lines long
  - Indent level should not be greater than one or two
  - functions should not be large enough to hold nested structures
- Do One Thing
  - They should do one thing and do it well and they should do it only
  - The reason we write functions is to decompose a larger concept into a set of steps at the next level of abstraction
- One level of abstraction per function
  - Mixing levels of abstractions within a function is always confusing
- Reading Code from Top to Bottom: The Stepdown Rule
  - We want to be able to read the program as though it were a set of `TO` paragraphs each of which is descrbing the current level of abstraction and referencing subsequent `TO` paragraphs at the next level down
- Switch Statements
  - Its hard to make a switch statement that does one thing because their nature is to do `N` things.
  - But we can make sure each switch statement is buried in a low-level class and never repeated: through [**POLYMORPHISM**](<https://en.wikipedia.org/wiki/Polymorphism_(computer_science)>)
    - Polymorphism describes a pattern in object oriented programming in which classes have different functionality while sharing a common interface
    - The example in the book p. 39 they turn a function into a class that has an interface that is a factory and then an implementation class that implements the factory to create new instances
  - Use Descriptive Names
    - Desribe what the function does
    - Don't be afraid to make a name long and don't be afraid to spend time finding a name
  - Function Argumentss
    - The ideal number of arguments for a function zero (niladic)
    - Next is one (monadic)
    - Next is two (dyadic) and then three (triadic) and three should be avoided whenever possible
    - More than three (polyadic) requires very special justiciation and shouldn't be used
    - Arguments are even harder from a testing point of view
- Common Monadic Forms
  - Two common reasons:
    - You may be asking a question about that argument or;
    - You may be transforming it into somthing else and `returning it`
- Flag Arguments
  - They are UGLY!!!
  - Passing a boolean into a function is truly terrible practice
  - Refactor into multiple functions instead
- Dyadic Functions
  - Harder to understand than a function with one argument
  - Cartesian points naturally have two values however they are ordered components of a single value
  - They are not evil but they come at a cost and you should try to re write them to use only one argument by pulling down complexity or creating multiple functions within a class
- Triads
  - These are significantly harder to understand then dyadic and should be thought about carefully before creating
- Argument Objects
  - Reducing the number of arguments by creating objects out of them is a good thing
- Argument Lists
  - Same idea as objects and used when you want to pass a variable number of arguments
- Verbs and Keywords
  - **The function and argument should be a nice verb/noun pair ie: `writeField(name)`**
  - Or use a `keyword` form of a function name ie: `assertExpectedEqualsActual(expected, actual)`, this mitigates the problem of having to remember the ordering of the arguments
- Have No Side Effects
  - Side effects are lies
  - They often result in strange temporal couplings and order dependencies
  - See p. 44 for function example
- Output Arguments
  - In general they should be avoided
  - Output arguments disappears in OO leanguages because `this` is intended to act as an output argument
- Command Query Separation
  - Functions should either do something or answer something not both
  - Either your function should change the state of an object or it should return some information about that object
- Prefer Exceptions to Returning Error Codes
  - When you return an error code you create the problem that the caller must deal with the error immediately
  - If you use execptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simplified
- Extract Try/Catch Blocks
  - He argues they are ugly and they confuse the structure of the code and mix error processing with normal processing
  - Better to extract the bodies of the try/catch out into functions of their own (p.47)
- Error handling is one thing
  - Just as functions should do one thing error handling is one thing
- The Error.java Dependency Magnet
  - Many other classes must import and use them
  - This puts a negative pressure on the Error class
- DON'T REPEAT YOURSELF
  - Duplication may be at the root of all evil in software
  - It appears that since the invention of the subroutine innovations in software dev have been an ongoing attempt to eliminate duplication from our source code
- Structured Programming
  - Edsger Dijkstra (structured programming) said that every function and every block within a function should have one entry and one exit, by this logic should only be one return, no `break` or `continue` and never any `goto` statements
  - However, if you keep your functions small this rule serves little benefit
  - So in a small function the occasional `return`, `break` or `continue` does no harm and can sometimes be more expressive
- How Do You Write Functions Like This?
  - Write down your thoughts, then massage it and restructure it, refine it until it reads the way you want it to read
  - Shrink methods, re order them, change names and eliminate duplication
  - In the end you end up with functions that follow the rules laid out in this chapter
- Conclusion
  - Functions are verbs and classes are the nouns (way to describe a system)
  - The art of programming is, and has always been, the art of language design
  - Never forget your real goal is to tell the story of the system

## Ch. 4 - Comments

- Comments
  - Comments are like Schindler's list not "pure good"
  - At best comments are a necessary evil
  - Don't comment bad code - rewrite it
  - He feels comments are always failures, failure to not express ourself in code
  - He says they lie not always and not intentionally, reason being programmers can't realistically maintain them
  - Truth can only be found in one place: code
- Comments Do Not Make up for bad code
  - Don't write a mess, spend time to clean it up instead of writing comments
- Explain Yourself in Code
  - A lot of times you can simplify code that would otherwise need a comment by creating a function with a descriptive name that says the same thing as the comment you would write
- Good Comments
  - Some comments are necessary or beneficial but the only truly good comment is the one you found a way not to write
  - Legal Comment
    - Copyright and authorship
  - Informative Comments
    - Sometimes useful to provide basic information with a comment ie regex
  - Explanation of Intent
    - Sometimes a comment goes beyond just useful information about the implementation and provides the intent behind a decision
  - Clarification
    - Sometimes its helpful to translate the meaning of some obscure argument or return value into something readable
    - When its part of a standard library or in code you can't alter it might be helpful
  - Warning of consequences
    - Sometimes it is useful to wanr other programmers about certain consequences
  - TODO Comments
    - Jobs that programmers thing should be done and myabe cannot be done right now
    - It is not an excuse to leave bad code in the system
  - Amplification
    - A commment may be used to amplify the importance of something that otherwise seem inconsequential
  - Javadocs in Public APIs
    - Extremly important and useful but be careful because they can be just as misleading and dishonest
- Bad Comments
  - Most comments fall into this category as htey are cruthes or excuses for poor code
  - Mumbling
    - Putting a comment because you feel you should is a hack
    - Any comment that forces you to look in another module for the menaing it has failed to communicate to you
  - Redundant Comments
    - Don't do it
  - Misleading Comments
    - Sometimes comments aren't precise or quite accurate and cause more trouble than harm
  - Mandated Comments
    - It is silly to have a rule that every variable or function needs to have a comment, it is just clutter and lead to disorganization and confusion
  - Journal Comments
    - People used to log every change that was made to a file before version control, don't do this
  - Noise Comments
    - these resonate the obvious and provide no new information
    - They are so noisy we learn to ignore them
    - Replace the temptation to create noise with determination to clean your code
  - Scary Noise
    - Just don't add noise
  - Don't use a comment when you can use a function or a variable
    - Rewrite code to leverage a variable or function
  - Position Markers
    - They clutter and should be eliminated
  - Closing Brace Comments
    - People will comment the end of their braces to remind them what it is the end of, instead shorten that piece of code
  - Attributions and bylines
    - Because source control exists don't add attributions
  - Commented-Out Code
    - DON'T DO THIS!!!
  - HTML Comments
    - Html in source code comments is an abonmination
  - Nonlocal Information
    - Make sure your comment appears next to the code it is meant to comment on
  - Too Much Information
    - Don't put interesting historical discussions or irrelevant descriptions
  - Inobvious connection
    - The connection between a comment and the code it describes should be obvious
  - Function Headers
    - A well chosen name for a small function that does one thins is usally better than a comment header

## Ch. 5 Formatting

- The Purpose of Formatting
  - Code forammtting is about communication and communication is the professsional developer;s first order of business
  - Perhaps you thought that "getting it working" was the first order of business but he says he hope by now after reading the book you no longer think that
  - Your style and discipline survives, even though your code does not
- Vertical Formatting
  - The size of the files themselves
  - Small files are usually easier to understand than large files are
- The Newspaper Metaphor
  - A file should be like a newspaper article, starting with a headline then a paragraph summarizing and then as you go down the details increase
  - So as a code file the top most parts of the source file should provide the high-level comcepts and algorithms. Details should increase as we move downward
  - If a newspaper were just one long story containing a dis organized agglomeration of facts, dates and name then we simply would not read it
- Vertical Openness Between Concepts
  - Keep blank space between new concepts, as it gives a visual cue and it has a profound impact on the visual layout of the code
- Vertical Density
  - If openness separates concepts, then vertical density implies close association
  - Associate lines of code that are tightly related vertically dense
- Vertical Distance
  - Concepts that are closely related should be kept verticaly close to each other
  - Also closely related concepts should not be separated into different files unless you have a very good reason
  - We want to avoid forcing our readers to hop around thorugh our source code
  - _Variable Declarations_
    - They should be declared as close to their usage as possible
    - Because our functions are short, variables should appear at the top of each function
    - Control variables should be usually declared within the loop statement
  - _Instance Variables_
    - Shoould be declared at the top of the class
  - _Dependent Functions_
    - They should be vertically close and the topmost function calls those below it and then in turn those below call those even further below
  - _Conceptual Affinity_
    - Certain bits of code want to be near other bits
    - The stronger the affinity the less vertical distance there shoiuld be between them
- Vertical Ordering
  - In general we want function call dependencies to point in the downward direction
- Horizontal Formatting
  - The Hollerith limit is 80 but he says edging out at 100 or 120 but no longer
- Horizontal Openness and Density
  - Surround assignment operatos with white space to accentuate them
  - Accentuate the precendence of operators
- Horizontal Alignment
  - He prefers unaligned declarations and assignments as shown below
  - _Indentation_
    - A source file is a hierarchy like an outline
    - To make the hierarchy visable we indent
    - Without indentation, programs would be virtaully unreadable by humans
  - _Breaking Indentation_
    - He prefers to always expand and intent the scopes and not to have if statements or things on the same line
  - _Dummy Scopes_
    - Sometimes the body of a while or for loop is a dummy, avoid them or properly intent the body and put them in brackets
- Team Rules
  - The team should agree on a set of formatting rules and everyone abides by those rules
  - A good software system is composed of a set of documents that read nicely
  -
