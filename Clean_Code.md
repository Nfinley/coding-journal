# Clean Code

Notes from book club and reading (started 11/1/2019)

## Important Concepts/Terms

- Depency Injection (DI)
- Inversion of Control
- Abstract Factory
- Open-Closed Principle
- Single Responsibility Principle

## Ch 1: Clean Code

- Total Cost of Owning a Mess
  - LeBlanc's law: Later equals never
  - The larger your code bass gets and the messier it gets, the less productivity you see
- Attitude
  - It is our job to defend the code with equal passion to our managers defending the schedule and requirements
- The Primal Conundrum
  - Developers know that previous messes slow them down, yet they feel the pressure to make messes in order to meet deadlines
  - However, the second part is wrong, you will not make the deadline by making a mess
  - The only way to make the deadline - the only way to go fast - is to keep the code as cleas as possible at all times
- The Art of Clean Code?
  - Requires use of "code-sense"
  - A programmer who can write clean code is an artist who can take a blank screen through a series of transformations until it is an elegantly coded system
- What is Clean Code?
  - Bjarne Stroustrup (Inventor of C++)
    - Likes code to be elegant and efficient, and clean code does one thing well
    - Clean code exhibits close attention to detail
    - Clean code is focused
  - Grady Booch (author of OO analysis and design with applications)
    - He says: Clean code is simple and direct
    - He takes a readability perspective and we should have 'crisp abstractions'
      - In that our code should be matter of fact as opposed to speculative
  - "Big" Dave Thomas (founder of OTI, gofather Eclipse strategy)
    - He focuses on readability but also asserts clean code makes it easy for other people to enhance it
    - He also ties cleaniness to tests
  - Michael Feathers (author of Working Effectively with Legacy Code)
    - Clean code looks like it was written by someone who cares about the code they write
    - Clean code is code that has been taken care of
  - Ron Jeffries (author of extreme programming Installed and adventures in C#)
    - Run all tests
    - Contains no duplication
    - Expresses all the esign ideas that are in the system
    - He focuses on Duplication and expressiveness
    - Also functions should do one thing, tiny abstractions
  - Ward Cunningham (inventor of Wiki, godfather of all those who care about code)
    - He expects that when you read clean code you won't be suprised at all, you won't expend much effort
    - Makes the language look like it was made for the problem
- We are Authors
  - Because we spend about 10:1 ratio of reading to writing code making it easier to read makes it easier to write
- The Boy Scout Rule

  - Code must be kept clean over time
  - Leave the campground cleaner than you found it

## Ch 2: Meaningful Names

- Use Intention-Revealing Names
  - If a name requires a comment then it does not reveal intent
  - Name with intention
- Avoid Disinformation
  - We must avoid levaing false queus that obscure the meaning of the code
  - Spelling similiar concepts similarily is information, using inconsistent spellins is disinformation
- Make Meaningful Distinctions
  - Number-series name is the opposite of intentional naming
  - Don't use language reserved words in naming like `variable` or `table`
- Use Pronounceable Names
  - ie: use `generationTimeStamp` instead of `genymdhms`
- Use Searchable Names
  - Single letter names are not advised
- Avoid Encodings
  - They are seldom pronounceable and are easy to mis-type
- Hungarian Notation
- Member Prefixes
  - you don't need to prefix member vairables
- Interfaces and Implementations
  - Don't code for the interface (ie: `IShapeFactory`)
- Avoid Mental Mapping
  - Clarity is King
- Class Names
  - They should have noun or noun phrare names like `Customer` or `AddressParser`
  - Should not be a verb
- Method Names
  - Should have verb or verb phrase names like `postPayment`, `deletePage`
- Don't be Cute
  - Say what you mean, mean what you say
- Pick One Word per Concept
  - Ie pick one from `fetch, get and retrieve` when naming things of this type
- Don't Pun
- Use Solution Domain Names
  - Its not wise to draw all names from the problem domain because we don't want to ask the customer they mean
  - Use computer science terms where applicable
- Use Problem Domain Names
  - When no "programmer-eese" is available use the problem domain name
- Add Meaningful Context
  - see listing 2-2 pg. 28 and 29
- Don't Add Gratuitous Context
  - If you app is Gas Station Deluxe don't add `GSD` to every class or function
  - Shorter Names are generally better than longer name so long as they are clear

## Ch 3: Functions

- Small!
  - They should be small and the second rule is that they should be smaller than that
  - No more than 20 lines long
  - Indent level should not be greater than one or two
  - functions should not be large enough to hold nested structures
- Do One Thing
  - They should do one thing and do it well and they should do it only
  - The reason we write functions is to decompose a larger concept into a set of steps at the next level of abstraction
- One level of abstraction per function
  - Mixing levels of abstractions within a function is always confusing
- Reading Code from Top to Bottom: The Stepdown Rule
  - We want to be able to read the program as though it were a set of `TO` paragraphs each of which is descrbing the current level of abstraction and referencing subsequent `TO` paragraphs at the next level down
- Switch Statements
  - Its hard to make a switch statement that does one thing because their nature is to do `N` things.
  - But we can make sure each switch statement is buried in a low-level class and never repeated: through [**POLYMORPHISM**](<https://en.wikipedia.org/wiki/Polymorphism_(computer_science)>)
    - Polymorphism describes a pattern in object oriented programming in which classes have different functionality while sharing a common interface
    - The example in the book p. 39 they turn a function into a class that has an interface that is a factory and then an implementation class that implements the factory to create new instances
  - Use Descriptive Names
    - Desribe what the function does
    - Don't be afraid to make a name long and don't be afraid to spend time finding a name
  - Function Argumentss
    - The ideal number of arguments for a function zero (niladic)
    - Next is one (monadic)
    - Next is two (dyadic) and then three (triadic) and three should be avoided whenever possible
    - More than three (polyadic) requires very special justiciation and shouldn't be used
    - Arguments are even harder from a testing point of view
- Common Monadic Forms
  - Two common reasons:
    - You may be asking a question about that argument or;
    - You may be transforming it into somthing else and `returning it`
- Flag Arguments
  - They are UGLY!!!
  - Passing a boolean into a function is truly terrible practice
  - Refactor into multiple functions instead
- Dyadic Functions
  - Harder to understand than a function with one argument
  - Cartesian points naturally have two values however they are ordered components of a single value
  - They are not evil but they come at a cost and you should try to re write them to use only one argument by pulling down complexity or creating multiple functions within a class
- Triads
  - These are significantly harder to understand then dyadic and should be thought about carefully before creating
- Argument Objects
  - Reducing the number of arguments by creating objects out of them is a good thing
- Argument Lists
  - Same idea as objects and used when you want to pass a variable number of arguments
- Verbs and Keywords
  - **The function and argument should be a nice verb/noun pair ie: `writeField(name)`**
  - Or use a `keyword` form of a function name ie: `assertExpectedEqualsActual(expected, actual)`, this mitigates the problem of having to remember the ordering of the arguments
- Have No Side Effects
  - Side effects are lies
  - They often result in strange temporal couplings and order dependencies
  - See p. 44 for function example
- Output Arguments
  - In general they should be avoided
  - Output arguments disappears in OO leanguages because `this` is intended to act as an output argument
- Command Query Separation
  - Functions should either do something or answer something not both
  - Either your function should change the state of an object or it should return some information about that object
- Prefer Exceptions to Returning Error Codes
  - When you return an error code you create the problem that the caller must deal with the error immediately
  - If you use execptions instead of returned error codes, then the error processing code can be separated from the happy path code and can be simplified
- Extract Try/Catch Blocks
  - He argues they are ugly and they confuse the structure of the code and mix error processing with normal processing
  - Better to extract the bodies of the try/catch out into functions of their own (p.47)
- Error handling is one thing
  - Just as functions should do one thing error handling is one thing
- The Error.java Dependency Magnet
  - Many other classes must import and use them
  - This puts a negative pressure on the Error class
- DON'T REPEAT YOURSELF
  - Duplication may be at the root of all evil in software
  - It appears that since the invention of the subroutine innovations in software dev have been an ongoing attempt to eliminate duplication from our source code
- Structured Programming
  - Edsger Dijkstra (structured programming) said that every function and every block within a function should have one entry and one exit, by this logic should only be one return, no `break` or `continue` and never any `goto` statements
  - However, if you keep your functions small this rule serves little benefit
  - So in a small function the occasional `return`, `break` or `continue` does no harm and can sometimes be more expressive
- How Do You Write Functions Like This?
  - Write down your thoughts, then massage it and restructure it, refine it until it reads the way you want it to read
  - Shrink methods, re order them, change names and eliminate duplication
  - In the end you end up with functions that follow the rules laid out in this chapter
- Conclusion
  - Functions are verbs and classes are the nouns (way to describe a system)
  - The art of programming is, and has always been, the art of language design
  - Never forget your real goal is to tell the story of the system

## Ch. 4 - Comments

- Comments
  - Comments are like Schindler's list not "pure good"
  - At best comments are a necessary evil
  - Don't comment bad code - rewrite it
  - He feels comments are always failures, failure to not express ourself in code
  - He says they lie not always and not intentionally, reason being programmers can't realistically maintain them
  - Truth can only be found in one place: code
- Comments Do Not Make up for bad code
  - Don't write a mess, spend time to clean it up instead of writing comments
- Explain Yourself in Code
  - A lot of times you can simplify code that would otherwise need a comment by creating a function with a descriptive name that says the same thing as the comment you would write
- Good Comments
  - Some comments are necessary or beneficial but the only truly good comment is the one you found a way not to write
  - Legal Comment
    - Copyright and authorship
  - Informative Comments
    - Sometimes useful to provide basic information with a comment ie regex
  - Explanation of Intent
    - Sometimes a comment goes beyond just useful information about the implementation and provides the intent behind a decision
  - Clarification
    - Sometimes its helpful to translate the meaning of some obscure argument or return value into something readable
    - When its part of a standard library or in code you can't alter it might be helpful
  - Warning of consequences
    - Sometimes it is useful to wanr other programmers about certain consequences
  - TODO Comments
    - Jobs that programmers thing should be done and myabe cannot be done right now
    - It is not an excuse to leave bad code in the system
  - Amplification
    - A commment may be used to amplify the importance of something that otherwise seem inconsequential
  - Javadocs in Public APIs
    - Extremly important and useful but be careful because they can be just as misleading and dishonest
- Bad Comments
  - Most comments fall into this category as htey are cruthes or excuses for poor code
  - Mumbling
    - Putting a comment because you feel you should is a hack
    - Any comment that forces you to look in another module for the menaing it has failed to communicate to you
  - Redundant Comments
    - Don't do it
  - Misleading Comments
    - Sometimes comments aren't precise or quite accurate and cause more trouble than harm
  - Mandated Comments
    - It is silly to have a rule that every variable or function needs to have a comment, it is just clutter and lead to disorganization and confusion
  - Journal Comments
    - People used to log every change that was made to a file before version control, don't do this
  - Noise Comments
    - these resonate the obvious and provide no new information
    - They are so noisy we learn to ignore them
    - Replace the temptation to create noise with determination to clean your code
  - Scary Noise
    - Just don't add noise
  - Don't use a comment when you can use a function or a variable
    - Rewrite code to leverage a variable or function
  - Position Markers
    - They clutter and should be eliminated
  - Closing Brace Comments
    - People will comment the end of their braces to remind them what it is the end of, instead shorten that piece of code
  - Attributions and bylines
    - Because source control exists don't add attributions
  - Commented-Out Code
    - DON'T DO THIS!!!
  - HTML Comments
    - Html in source code comments is an abonmination
  - Nonlocal Information
    - Make sure your comment appears next to the code it is meant to comment on
  - Too Much Information
    - Don't put interesting historical discussions or irrelevant descriptions
  - Inobvious connection
    - The connection between a comment and the code it describes should be obvious
  - Function Headers
    - A well chosen name for a small function that does one thins is usally better than a comment header

## Ch. 5 Formatting

- The Purpose of Formatting
  - Code forammtting is about communication and communication is the professsional developer;s first order of business
  - Perhaps you thought that "getting it working" was the first order of business but he says he hope by now after reading the book you no longer think that
  - Your style and discipline survives, even though your code does not
- Vertical Formatting
  - The size of the files themselves
  - Small files are usually easier to understand than large files are
- The Newspaper Metaphor
  - A file should be like a newspaper article, starting with a headline then a paragraph summarizing and then as you go down the details increase
  - So as a code file the top most parts of the source file should provide the high-level comcepts and algorithms. Details should increase as we move downward
  - If a newspaper were just one long story containing a dis organized agglomeration of facts, dates and name then we simply would not read it
- Vertical Openness Between Concepts
  - Keep blank space between new concepts, as it gives a visual cue and it has a profound impact on the visual layout of the code
- Vertical Density
  - If openness separates concepts, then vertical density implies close association
  - Associate lines of code that are tightly related vertically dense
- Vertical Distance
  - Concepts that are closely related should be kept verticaly close to each other
  - Also closely related concepts should not be separated into different files unless you have a very good reason
  - We want to avoid forcing our readers to hop around thorugh our source code
  - _Variable Declarations_
    - They should be declared as close to their usage as possible
    - Because our functions are short, variables should appear at the top of each function
    - Control variables should be usually declared within the loop statement
  - _Instance Variables_
    - Shoould be declared at the top of the class
  - _Dependent Functions_
    - They should be vertically close and the topmost function calls those below it and then in turn those below call those even further below
  - _Conceptual Affinity_
    - Certain bits of code want to be near other bits
    - The stronger the affinity the less vertical distance there shoiuld be between them
- Vertical Ordering
  - In general we want function call dependencies to point in the downward direction
- Horizontal Formatting
  - The Hollerith limit is 80 but he says edging out at 100 or 120 but no longer
- Horizontal Openness and Density
  - Surround assignment operatos with white space to accentuate them
  - Accentuate the precendence of operators
- Horizontal Alignment
  - He prefers unaligned declarations and assignments as shown below
  - _Indentation_
    - A source file is a hierarchy like an outline
    - To make the hierarchy visable we indent
    - Without indentation, programs would be virtaully unreadable by humans
  - _Breaking Indentation_
    - He prefers to always expand and intent the scopes and not to have if statements or things on the same line
  - _Dummy Scopes_
    - Sometimes the body of a while or for loop is a dummy, avoid them or properly intent the body and put them in brackets
- Team Rules
  - The team should agree on a set of formatting rules and everyone abides by those rules
  - A good software system is composed of a set of documents that read nicely

## Ch 6 Objects and Data Structures

- Data Abstraction
  - Hiding implementation is not just a matter of putting a layer of functions between the variables, it is about abstractions
  - A class exposes abstract interfaces that allow its users to manipulate the _essense_ of the data, without having to know its implementation
  - We do not want to expose the details of our data but rather express our data in abstract terms
- Data/Object Anti-Symmetry
  - Objects hide their data behind abstractions and expose functions that operate on that data
  - Data structures expose their data and have no meaningful functions
  - **Procedural code (6-5 p.96) (code using data structures) makes it easy to add new functions without changing the existing data structures. OO code, makes it easy to add new classes without changing existing functions**
  - The compliment is true: **Procedural code makes it hard to add new data structures because all the functions must change. OO code makes it hard to add new functions because all the classes must change**
- The Law of Demeter
  - It says a module should not know about the innards of the objects it manipulates
  - This means it should not expose its internal structure
  - A function f, on class C should not invoke any methods on objects that are returned by any of the allowed functions, only talk to its friends not strangers
- Train Wrecks
  - Chains of calls like: `final Strings outputDir = ctxt.getOptions().getScratch().getAbsolutePath()` is a train wreck because it looks like a bunch of coupled traing cards
  - They are considered slpppy style and should be avoided
  - The above would be fixed by each being set to a variable of the other
- Hybrids
  - When structures exist that are half objecst and half data structure
  - Don't do them
- Data Transfer Objects
  - Quintessential form of a data strcuture is a class with public variables and no functions called a data transfer object
  - More common is the "BEAN" form, they have private variables manipulated by getters and setters. The quasi-encapsulation of beans seems to make some OO purists feel better but usually provides no other benefit
- Active Record
  - These are a special form of a DTO. They are data structures with public (or bean accessed) variables
  - They also typically have methods like `save` and `find`
  - Unfortunately we often find devs treat these data structures as objects and try to put business logic in them making them awkward and a hybrid
- Conclusion
  - Objects expose behavior and hide data.
    - Easy to add new kinds of objects without changing behaviors but hard to add new behaviors to existing objects
  - Data structures expose data and have no significant behavior
    - Easy to add new behaviors to existing data structures but makes it hard to add new data structures to existing functions

## Ch 7 Error Handling (p103)

- Error handling is important but if it obscures logic it is wrong
- Use Exceptions Rather than Return Codes
  - It is better to throw an exception when you encounter an error
- Write your Try-Catch-Finally Statement first
  - Try to write tests that force exceptions, and then add behavior to your handler to satisfy your tests
  - Stresses to start by writing the try catch blocks that coulc throw exceptions
- Use Unchecked Exceptions
  - The price of a checked exception is an Open/Closed Principle Violation
  - If you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch
- Provide Context With Exceptions
  - Each error you throw should provide enough context to determine the source and location of the error
  - Create information error messages and pass them along with your exceptions
- Define Exception Classes in Terms of a Caller's Needs
  - There are amany ways to define errors, the most important should be how they are caught
  - His example had a call with a bunch of catch blocks in which he abstracted out to its own class that took in a more generic error and then handled it, pulled complexity downward
  - Create a wrapper around third party APIs, this is best practice
  - Doing this minimizes the dependencies on that API
  - Often a single exception class is fine for a particular piece of code
- Define the Normal FLow
  - Sometimes you don't need to abort and in this case you may not need to write a catch block, instead the example he gives is to have your class return a default object that handles the special case for you, he calls this a SPECIAL CASE OBJECT
- Don't return null
  - Just don't do it, find a way to return a special case object or consider throwing an exception
- Don't Pass Null
  - Returning null is base but passing null into a function is even worse
  - Not a whole lot of elegant options to handle so instead forbid `null` from being passed at all
- Conclusion
  - Code is readable but must also be robust
  - We can do this if we view error handling as a separate concern something that is independent of our main logic

## Ch 8 Boundaries (p.113)

- Using Third-Party Code
  - Third-party packages strive for braod applicability so they can work in many environments and appeal to wide base
  - Users on the other hand want an interface that is focused on their needs
  - This causes a tension between providers and users and can cause problems at the boundaries of our systems
  - The example he gives is the use of a util.Map library in Java and instead of exposing all of the functionality to all of the callers he creates a call where the interface at the boundary(Map) is hidden
  - He is not suggesting encapsulating every user of Map, but advising not to pass any interface at a boundary around
  - Instead if you use a boundary interface keep it inside the class, or close family of class. Avoid returning from it or accpeting it as an argument
- Exploring and Learning Boundaries
  - Instead of trying out the new third party library in production code, He suggests writing "learning tests" to explore our understanding of third-party code
  - Essentially doing controlled experiments that check out understanding of that API
- Learning log4j
  - He uses an example library page 117 to go through how to write tests to discover how to use a library
- Learning Tests are Better Than Free
  - The learning tests end up costing nothing. We had to learn the API anyway and writing tests isolated the way to get that knowledge
  - They were precise experiments that helped increase our understanding
  - Also helps when the library puts out new releases to run and see if there are behavorial differences
- Using Code That Does not Yet Exist
  - They were working on a system that had a boundary at a Transmitter, so they created their own interface with a fake transmitter api until they had the specs for the real one.
  - They encapsulated the interaction with the API using the Adapter pattern, which allows for a single place to change when the API evolves
  - This design also gives very convenient "SEAM" in code for testing, and you can create boundary tests from the real API to make sure the correct usage is occuring
- Clean Boundaries
  - Good software designs accocmodate change without huge investment and sure future change it not too closely
  - Code at boundaries need clear separation and test that define expectations.
  - Avoid letting too much of our code know about third-party particulars
  - We manage thrid-party boundaries by having very few places in the code that refer to them
    - We may wrap them, use an ADAPTER to convert from perfect interface to provided interface

## Ch 9 Unit Tests (p 121)

- The Three Laws of TDD
  - First Law: You may not write production code until you have written failing unit test
  - Second Law: You may not write more of a unit test than is sufficient to fail, and not compiling is failing
  - Third Law: You may not write more production code than is sufficient to pass the currently failing test
- Keeping tests clean
  - Having dirty tests is worse than having no tests
  - Test code is just as important as test code and must be kept clean
- Tests Enable the -ilities
  - If you have tests you do not fear making changes to the code
- Clean Tests
  - Three things: Readability, Readability, Readability!!!!
  - What makes them readable: Clarity, simplicity, and density of expression
  - Sometimes you can use the BUILD_OPERATE_CHECK pattern to construct your tests
- Domain-Specific Testing Language
  - Write a set of utility functions that allow you to obscucate the other APIS, this allows higher readability and you create a set of tools explicitly for testing
- A Dual Standard
  - It must be simple, succinct and expressice but it not need to ne as efficient as production code
  - Things like performance, memory utilization might differ between test and prod but never involve issues of cleanliness
- One Assert Per Test
  - Assert one thing per test
  - You can use the TEMPLATE METHOD patter and putting the given/when parts in a base class and the then parts in different derivatives
  - But if the work of breaking it out seems like too much for what you are trying to accomplish you can use multiple asserts
  - It is a good guideline
- Single Concept Per Test
  - Perhaps a better rule than single assert is to not have multiple concepts per test
  - It is better to minimize the numbern of assertions and just test one concept
- F.I.R.S.T
  - Clean tests follow five rules:
    - FAST: They should be fast
    - INDEPENDENT: Tests should not depend on each other
    - REPEATABLE: Tests should be repeatable in any environment
    - SELF-VALIDATING: Tests should have a boolean output, they pass or fail
    - TIMELY: Test need to written in a timely fashion, they should be written just before the production code that makes them pass
- Conclusion
  - Tests must be clean because they preserve and enhance the flexibility, maintainability and reusability of the production code

## Ch 10 Classes (p 135)

- Class Organization
  - Classes should start with a list of variables, then private static variables, then private instance variables,
  - Encapsulation
    - Loosening encapsulation should always be a last resort
- Class Should be Small!
  - First rule, classes should be small
  - Second rule, classes is they should be smaller than that
  - We count responsibilities when measuring size of classes
  - Name of the class should describe what responsibility it fulfills
- The Single Responsibility Principle
  - Classes should have one and only one reason to change
  - They should have one reponsibility and one reason to change
  - Identifying responsbilities often helps us recognize and create better abstractions
  - One of the most important concept in OO design
  - The primary goal in managing complexity is to organize it so a developer knows where to look and to only understand the directly affected complexity
- Cohesion
  - Classes should have a small number on instance variables
  - A class in which each variable is used by each method is maximally cohesive
  - When Cohesion is high, it means that the methods and variables of the class are co-dependent and hang together as a logical whole
- Maintaining Cohesion Results in Many Small Classes
  - When classes lose cohesion split them up, break them down into more classes
- Organizing for Change
  - For most systems, change is continual
  - The problem with "opening up" a class is that it introduces risk
  - Private method behavior that applies only to a small subset of a class can be a useful heuristic for spotting potential areas of improvement
  - **OPEN-CLOSED PRINCIPLE:** Classes should be open for extension but closed for modification
  - We want to structure our systems so that we muck with as little as possible when we update them with new or changed features
  - In ideal system we mae new features by extending the system, not by making modifications to existing code
- Isolating From Change
  - In OOP there are concrete class, which contain implementation details (Code) and abstract class which represent concepts only
  - When a client classes that depend on concrete class is at risk we can introduce using interfaces and abstract classes to help isolate the impact of the changes
  - If a system is decouple enough to be tested like on p. 150 it will be more flexible and promote more reuse
  - Lack of coupling means that the elements of our system are better isolated from each other and from change
  - **DEPENDENCY INVERSION PRINCIPLE:** Basically says that our class should depend on abstractions, not on concrete details
  - Abstractions can isolate all of the specific details of obtaining certing data like where a stock price is obtained

## Ch 11 Systems (p 153)

- How would you build a city?
  - Have a team that manages certain parts, some focus on big picture others the details
  - They also work because they have evolved apprpropriate leces of abstractoin and modularity that make it possible for individuals and "components" they manage to work effectively
- Separate Constructing a System from Using It
  - _Construction_ is a very different process than _USE_
  - > Software systems should separate the startup process, when the application objects are constructed and depenendcies are "wired" together; from the runtime logic that takes over after startup
  - _Separation of Concerns_ is one of the oldest and most important design techniques in our craft and the startup process is the first concern
  - We should neve let little convientient idioms lead to modularity breakdown
  - We should modularize the startup process from normal runtime logic and we should make sure we have a glabl consistent strategy for resolving our major dependencies
- Separation of Main
  - One way to separate construction from use is simply to move all aspects of construction to `main`
  - The `main` function builds the objects necessary for the system and passes them to the application, which simply uses them
  - The one way direction of dependency is away from main which means the application has no knowledge of `main` or the construction process
- Factories
  - Sometimes however we need to make the application responsible for `when` an object is created
  - **ABSTRACT FACTORY** pattern to give the application control of `when` to build something, but it keeps the details of that construction separate
  - See figure 11-2 (p 156) all dependencies point away from `main`, which means the application is decoupled from the details fo how to build X.
- Dependency Injection
  - This is a powerful mechanism for separating concstruction from use
  - **Inversion of Control**: moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the SRP
  - An object should not take responsponsibility for instantiating its dependencies, instead it should pass it to an "authoritative" mechanism thereby inverting control
  - In true dependcy injection, the class takes no direct steps to resolve its dependencies it is completely passive
- Scaling Up
  - It is a myth that we can get systems "right the first time"
  - Instead we should implement only today's stories then refactor and expand the system to implement new stories tomorrow: This is the essence of iterative and incremental agility.
  - "Software systems are unique compared to physical systems. Their architectures can grow incrementallym **if** we maintain the proper separation of concerns"
- Cross-Cutting Concerns
  - Concerns like persistence tend to cut across the natural object boundaries of a domain
  - For concerns where you have to spread the code that implements for example a persistence strategy across many objects, it is called a _cross-cutting concern_
  - **AOP - Aspect Oriented Programming**: a general purpose approach to restoring modulatiry for cross-cutting concerns
- Java Proxies (Aspect-like mechanism)
  - p. 161-162
  - Code volume and complixity are two drawbacks of proxies
- Pure Java AOP Frameworks
  - Spring AOP model follows declaritively supporting cross-cutting concerns using XML config files or Java annotations
- AspectJ Aspects
  - The most fully fetured tool for separating concerns
  - Drawback of AspectJ is the need to adopt several new tools and to learn new language constructs
- Test Drive the System Architecture
  - **Big Design Up Front**: The practice of designing everything up front before implementing anything at all
  - Software construction has its own physics: a lot of iterative exploration and discussion of details, even after construction starts
  - A Physical structure has to be BDUF, but software doesn't
  - If designed properly it is possible to make radical changes **if** the structure of the separates its concern effectively
  - Minimally coupled designs are appropriately simple at each level of abstraction and scope
  - We cannot go in "rudderless" but we must maintain the abality to change course
  - A good API should mostly disappear from view
  - > An optimal system architecure consists of modularized domains of concern, each of which is implemented with Plain Old Java Objects. The different domains are integrated together with minimally invasive Aspects of Aspect-Like tools. This architecture can be test-driven, just like code
- Optimize Decision Making
  - No one person can make all of the decisions
  - Postpone deicssions until the last possible moment
- Use Standards Wisely, When They Add Demonstrable Value
  - > Standards make it easier to reuse ideas and components, recruite people with relevant experience, encapsulate good ideas, and write components together. Howver, the process of creating standards can sometimes take too long for industry to wait, and some standards lose tocuh with the real needs of the adopters they are intended to serve.
- Systems Need Domain-Specific Languages
  - A Good DSL mimimizes the communications gap between a domain comcept and the code that implements it
- Conclusion
  - Systems must be clean too
  - Whether you are writing systems or individual modules, never forget to _use the simplest thing that can possibly work_

## Ch 12 Emergence (p.171)

- Four simple rules by Kent Beck:
  - Runs all the tests
  - Contains no duplication
  - Expresses the intent of the programmer
  - Minimizs the number the classes and methods
- Simple Design Rule 1: Runs All The Tests
  - A system that is comprehensively tested and passes all of its tests all of the time is a testable system
  - Systems that aren't testable aren't verifiable and arguably should never be deployed
  - Writing tests leads to better designs
  - It also leads to OO goals of low coupling and high cohesion
- Simple Design Rules 2-4: Refactoring

  - NO DUPLICATION:

    - Lines of code that look alike and duplicate implementation are both examples
    - You can use **THE TEMPLATE METHOD** : a pattern used for removing higher-level duplication

  - EXPRESSIVE:

    - Majority of cost of saftware project is long-term maintenance
    - Code should clearly express the intent of the author; this will reduce defects and shrink cost of maintenence
    - Express yourself via: choosing good names, writing small functions and classes, using standard nomenclature and well written unit tests
    - Take pride in your workmanship, care is a precious resource

  - MINIMAL CLASSES AND METHODS
    - It is important to keep methods and functions small, however we should be pragmatic and not go overboard
    - Goal it to keep the system small while we are also keeping out functions and classes small

## Ch 13 Concurrency (light on notes because not as crucial, p. 177)

- Why Concurrency?
  - Is a decoupling strategy
  - Helps decouple what gets done from when it gets done
  - This decoupling can dramtically improve the throughput and structure
- Myths and Misconceptions
  - Concurrency always improves performance: it can sometimes improve performance only when wait time is shared
  - Design does not change when writing concurrent programs: It can be remarkably different
  - Among others p.179
- Concurrency Defense Principles
  - SRP
    - Concurrency code should be separated from non-concurrent code
    - Recommendation: Keep your concurent code separate from other code
  - Corollary: Limit the scope of data
    - Recommendation: take encapsulation to heart, severly limit the access of any data that may be shared
  - Corollary: Use Copies of Data
    - When possible and if its not to memory intensive use copies of objects so as not to share code (merge back and end in single thread if needed)
  - Corollary: Threads should be as independent as possible
    - Isolate each thread as much as possible
    - Recomendation: Attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors
- Know Your Library
  - Reviews classes/methods available to you
- Know Your Execution Models
  - Producer - Consumer (184)
  - Readers - Writers (184)
  - Dining Philosophers
- Beware Dependencies Between Synchoronized Methods
  - Avoid using more than one method on a shared object
- Keep synchornized sections small
- Testing Threaded Code
  - Write tests that have the potential to expose problems and then run them frequently under different configs and load
- Get your nonthreaded code working first
  - Recomendation: Do not try to chase down nonthreading bugs and threading bugs all the same time. Make sure your code works outside of threads
- Make your threaderd code pluggable
  - make it work with many configurations
- Run on Different Platforms
- Automated
  - Use jiggling strategies to ferret our errors

## Ch 14 Successive Refinement (p 193)

- To write clean code you must first write dirty code and then clean it up
- Writing clean compositions is a matter of successive refinement
- On Incrementalism (p 212)
  - One of the best ways to ruin a program is to make massive changes to its structure in name of improvement
  - Its very hard to get the program working the same weay after the improvement
  - To avoid this use TDD as one of the central ideas is you must keep the system running at all times, I am not allowed to make a change that breaks that system
  - In order to achive this you must a hefty testing suite
- Much of software design is simply about partioning - creating appropriate places to put different kind of code
- It is not enough for code to work
- Never let code rot start

## Ch 15 JUnit Internals

- Review of the JUnit testing framework and breaking down of the ComparisonCompactor class (starting at p. 251)
- No module is immune from improvement and each of us has the responsisbility to leave the code a little better than we found it
- Refactoring is an iterative process full of trial and error, inevitably converging on something we feel is worthy of a professional.

## Ch 16 Refactoring SerialDate

- First Make It Work

## Ch 17 Smells and Heuristics

- Comments
  - C1: Inappropriate Information
    - Comments should be reserved for technical notes about code and design
  - C2: Obsolete comment
    - If it will be obsolete don't write it and get rid of them
  - C3: Redudant Comment
  - C4: Poorly Written Comment
  - C5: Commented-Out Code
    - When you see it, delete it! And don't do it
- Environment
  - E1: Build Requires More than one Step
  - E2: Tests Require more than one step
    - All tests should be able to be run with just one command
- Functions
  - F1: Too Many Arguments
    - should have a small number of arguments
  - F2: Output Arguments
    - They are counterintuitive
  - F3: Flag Arguments
    - Boolean arguments loudly declare that the function does more than one thing
  - F4: Dead Function
    - Methods that are never called should be discarded
- General

  - G1: Multiple Languages in One Source File
    - One file one language
  - G2: Obvious Behavior is unimplemented
    - Any function or class should implement the behaviors that another programmer could reasonably expect
  - G3: Incorrect Behavior at the Boundaries
    - Don't rely on intuition look for every boundary condition and write a test for it
  - G4: Overriden Safeties
    - Turning off failing tests and getting back to them later is as bad as pretending your credit cards are free money
  - G5: Duplication
    - DRY principle
    - Once and only one
  - G6: Code at Wrong Level of Abstraction
    - Constants, Variables or utility functions that pertain only to the detailed implementation should not be present in the base class
    - We don't want higher and lower level concepts mixed together
    - Isolating abstractions is one of the hardest things for software devs and no quick fix when you get it wrong
  - G7: Base Classes Depending on Their Derivatives
  - G8: Too Much Information
    - Well defined modules have very small interfaces that allow you do a lot with a little
    - Help keep coupling low by limiting information
    - Hide your data, hide your util functions, hide your contants and your temporaries
  - G9: Dead code
    - You find it in if/then, catch blocks or switch cases for cases that never fire
    - Remove it
  - G10: Vertical Separation
    - Variables and functions shoule be defined closely to where they are used
  - G11: Inconsistency
    - Once you choose a pattern stick with it
  - G12: Clutter
    - Keep your code clean, well organized and free of clutter
  - G13: Artifical Coupling
    - In general it is a coupling between two modules that serves no direct purpose
  - G14: Feature Envy
    - The methods of a class should be interested in the variables and functions of the classes they belong to, not the variables and functions of other classes
  - G15: Selector Arguments:
    - In general it is better to have many functions than to pass some code into a function to select a behavior
  - G16:Obscured Content
    - Code should be expressive
  - G17: Misplaced Responsibility
    - Most important decision a dev can make is where to put code
    - Principle of least surprise
  - G18: Inappropriate Static
  - G19: Use Explanatory Variables
  - G20: Function Names Should Say What They Do
  - G21: Understand the Algorithm
    - Its one thing to get it to "work", make sure you understand how it works
  - G22: Make Logical Dependencies Physical
  - G23: Prefer PolyMorhpism to If/Else or Switch/Case
  - G24: Follow Standard Conventions
  - G25: Replace Magic Numbers with Named Constants
  - G26: Be Precise
  - G27: Structure over convention
  - G28: Encapsulate conditionals
  - G29: Avoid Negative Conditionals
  - G30: Functions Should Do One Thing
  - G31: Hidden Temporal Coupling
  - G32: Don't Be Arbitrary
  - G33: Encapsulate Boundary Conditions
  - G34: Functions Should Descend Only One Level of Abstraction
    - May be on of the hardest heuristics to interpret and follow
  - G35: Keep Configurable data at high levels
  - G36:Avoid Transitive Navigation

- Java

  - J1: Avoid Long Import Lists by Using WildCards
  - J2: Don't Inherit Constants
  - J3: Constants vs Enums

- Names

  - N1: Choose Descriptive Names
  - N2: Choose Names at appropriate level of abstraction
  - N3: Use standard Nomenclature Where Possible
  - N4: Unambiguous Names
  - N5: Use Long Names for Long Scpres
  - N6: Avoid Encodingss
  - N7: Names Should describe Side-Effects

- Tests
  - T1: Insufficient Tests
  - T2: Use a Coverage Tool!
  - T3: Don't Skip Trivial Tests
  - T4: An ignored Test is a question about an ambiguity
  - T5: Test boundary Conditions
  - T6: Exhaustively Test Near Bugs
  - T7: Patterns of Failure Are Revealing
  - T8: Test Coverage Patterns can be revealing
  - T9: Tests Should be Fast
